import { AnswerChoice, Question, Survey } from './survey.types';

/**
 * Utility method to generate an object suitable for use with SurveyJS.
 *
 * @param {Survey} survey - Our internal representation of a survey.
 */
export function generateSurveyJsModel(survey: Survey) {
  const coreProperties = {
    title: 'PLUTO - Public Value Assessment Tool',
    showPageTitles: false,
    showProgressBar: 'top',
    questionsOnPageMode: 'questionPerPage',
    showPreviewBeforeComplete: 'showAllQuestions',
    widthMode: 'responsive',
    logo: 'logo.png',
    logoPosition: 'top',
    logoWidth: 120,
    logoHeight: 120,
    logoFit: 'contain',
    completedHtml: ' ',
  };
  const questionsWithPageTitle = survey.groups.flatMap(({ title, questions }) =>
    questions.map((question) => ({ ...question, pageTitle: title }))
  );
  const pages = questionsWithPageTitle.map((question) => {
    const { questionNumber } = questionLabelInverse(question.label);
    const name = pageLabel(questionNumber);
    const elements = [mapQuestion(question, questionNumber)];
    const { name: questionLabel } = elements[0];
    const title = `${question.pageTitle} - ${questionLabel}`;
    return { name, title, elements };
  });
  return { ...coreProperties, pages };
}

/**
 * Label generator for a survey page.
 *
 * @param {number} pageNumber - The page number to generate a label for.
 */
function pageLabel(pageNumber: number) {
  return `P${pageNumber}`;
}

/**
 * Inverse of {@link pageLabel}.
 * Returns the page number from a page label
 * under the assumption that the supplied label was generated by {@link pageLabel}.
 *
 * @param label - The page label to get the page number from.
 */
export function pageLabelInverse(label: string) {
  const pageNumber = parseInt(label.slice(1), 10);
  return { pageNumber };
}

/**
 * Label generator for an answer choice.
 *
 * @param {number} questionNumber - The question number to generate a label for.
 * @param {number} choiceNumber - The choice number to generate a label for.
 */
export function answerChoiceLabel(
  questionNumber: number,
  choiceNumber: number
) {
  return `A${questionNumber}.${choiceNumber}`;
}

/**
 * Inverse of {@link answerChoiceLabel}.
 * Returns the question number and choice number from an answer choice label
 * under the assumption that the supplied label was generated by {@link answerChoiceLabel}.
 *
 * @param {string} label - The answer choice label to get the question number and choice number from.
 */
export function answerChoiceLabelInverse(label: string) {
  const [questionNumberString, choiceNumberString] = label.split('.');
  const questionNumber = parseInt(questionNumberString.slice(1), 10);
  const choiceNumber = parseInt(choiceNumberString, 10);
  return { questionNumber, choiceNumber };
}

/**
 * Generates an object from a {@link AnswerChoice} appearing in the {@link Question}
 * identified by `questionNumber` at the `choiceNumber`th position, to be used with SurveyJS.
 *
 * @param {AnswerChoice} choice - The answer choice object to map.
 * @param {number} questionNumber - The question number of the question containing the answer choice.
 * @param {number} choiceNumber - The position where the answer choice appears in the question.
 */
function mapAnswerChoice(
  choice: AnswerChoice,
  questionNumber: number,
  choiceNumber: number
) {
  return {
    value: answerChoiceLabel(questionNumber, choiceNumber),
    text: choice.body,
  };
}

/**
 * Label generator for a question.
 *
 * @param {number} questionNumber - The question number to generate a label for.
 */
export function questionLabel(questionNumber: number) {
  return `Q${questionNumber}`;
}

/**
 * Inverse of {@link questionLabel}.
 * Returns the question number from a question label
 * under the assumption that the supplied label was generated by {@link questionLabel}.
 *
 * @param {string} label - The question label to get the question number from.
 */
export function questionLabelInverse(label: string) {
  const questionNumber = parseInt(label.slice(1), 10);
  return { questionNumber };
}

/**
 * Generates an object from a {@link Question} to be used with SurveyJS.
 *
 * @param {Question} question - The question object to map.
 * @param {number} questionNumber - The position where the question appears in the survey.
 */
function mapQuestion(question: Question, questionNumber: number) {
  const type = getQuestionType(question);
  const name = questionLabel(questionNumber);
  const title = `${question.body} (${getTickHint(question)})`;
  const isRequired = true;
  const validators = getQuestionValidators(question, questionNumber);
  const choices = question.choices
    .filter((choice) => choice.type === 'regular')
    .map((choice, choiceNumber) =>
      mapAnswerChoice(choice, questionNumber, choiceNumber + 1)
    );
  const separateSpecialChoices = false;
  const hasOther = getQuestionHasOther(question);
  const otherText = hasOther && getQuestionOtherText(question);
  const hasNone = getQuestionHasNone(question);
  const noneText = hasNone && getQuestionNoneText(question);
  const maxSelectedChoices =
    type === 'checkbox' && getQuestionMaxSelectedChoices(question);
  const description = questionDescription(question);
  return {
    type,
    name,
    description,
    title,
    isRequired,
    choices,
    separateSpecialChoices,
    ...((!!validators && { validators }) || undefined),
    ...((hasOther && { hasOther, otherText }) || undefined),
    ...((hasNone && { hasNone, noneText }) || undefined),
    ...((maxSelectedChoices && { maxSelectedChoices }) || undefined),
  };
}

function questionDescription(question: Question): string {
  return question.explanation || '';
}

/**
 * Logic for determining the hint about how many answer choices to tick.
 * The returned value will be used to suffix the question body.
 * E.g. " Which of the answers below best describe the data user? (tick one)".
 *
 * We already store the selection range in the metadata of the question,
 * therefore it is not necessary to store the tick hint in the question's body,
 * as it can be inferred from the selection range. This function defines the inference logic.
 *
 * @param {Question} question - The question to get the hint for.
 */
function getTickHint(question: Question) {
  const { start, end } = question.metadata.selection;
  const numChoices = question.choices.length;
  if (start === 1 && end === 1) {
    return 'tick one';
  } else if (start === 1 && end === numChoices) {
    return 'tick as many as necessary';
  }
  return `tick up to ${numberToWord(end)}`;
}

/**
 * Naive implementation of a number to word converter.
 * Works up to 10.
 *
 * @param {number} number - The number to convert to a word.
 */
function numberToWord(number: number) {
  if (number < 0 || number > 10) {
    throw new Error(`Unsupported number ${number}`);
  }
  const words = [
    'zero',
    'one',
    'two',
    'three',
    'four',
    'five',
    'six',
    'seven',
    'eight',
    'nine',
    'ten',
  ];
  return words[number];
}

/**
 * Determines the renderer to use for a question based on the selection range.
 * Currently, we expect all questions to be of type 'radiogroup' or 'checkbox'.
 *
 * @param {Question} question - The question to get the renderer for.
 */
function getQuestionType(question: Question) {
  const { selection } = question.metadata;
  if (selection.start === 1 && selection.end === 1) {
    return 'radiogroup';
  } else {
    return 'checkbox';
  }
}

/**
 * Determines whether the supplied question should have the role "other" in the SurveyJS form.
 *
 * @param {Question} question - The question to check.
 */
export function getQuestionHasOther(question: Question) {
  return question.choices.some(
    (choice) =>
      choice.type === 'otherExclusive' || choice.type === 'otherInclusive'
  );
}

/**
 * Extracts the answer choice text for the "other" choice of the supplied question.
 *
 * @param {Question} question - The question to get the "other" choice text for.
 */
function getQuestionOtherText(question: Question) {
  const choice = question.choices.find(
    (choice) =>
      choice.type === 'otherExclusive' || choice.type === 'otherInclusive'
  );
  if (choice) {
    return choice.body;
  }
  throw new Error('Question does not have an other choice');
}

/**
 * Determines whether the supplied question should have the role "none" in the SurveyJS form.
 *
 * @param {Question} question - The question to check.
 */
export function getQuestionHasNone(question: Question) {
  return question.choices.some((choice) => choice.type === 'none');
}

/**
 * Extracts the answer choice text for the "none" choice of the supplied question.
 *
 * @param {Question} question - The question to get the "none" choice text for.
 */
function getQuestionNoneText(question: Question) {
  const choice = question.choices.find((choice) => choice.type === 'none');
  if (choice) {
    return choice.body;
  }
  throw new Error('Question does not have a none choice');
}

/**
 * Returns `question.metadata.selection.end` of the supplied question.
 *
 * @param {Question} question - The question to get the maximum number of selected choices for.
 */
function getQuestionMaxSelectedChoices(question: Question) {
  const {
    selection: { end },
  } = question.metadata;
  return end;
}

/**
 * Creates an array of SurveyJS validators to be attached to the supplied question.
 * If there is a question with an answer choice  of role "otherExclusive" (e.g.: "none of the above"),
 * then we forbid the simultaneous selection of any other answer choice.
 * We do this only for questions of type "checkbox" as it is not possible to select multiple choices
 * when the question is of type "radiogroup" by definition.
 *
 * See: {@link https://surveyjs.io/form-library/documentation/data-validation}
 *
 * @param {Question} question - The question to create the validators for.
 * @param {number} questionNumber - The number of the question to create the validators for.
 */
function getQuestionValidators(question: Question, questionNumber: number) {
  const validators = [];
  const questionHasNoneAndHasExclusiveOther =
    getQuestionHasNone(question) &&
    question.choices.some((choice) => choice.type === 'otherExclusive');
  if (
    questionHasNoneAndHasExclusiveOther &&
    getQuestionType(question) === 'checkbox'
  ) {
    validators.push(getExclusiveOtherValidator(questionLabel(questionNumber)));
  }
  return validators;
}

/**
 * Creates a SurveyJS validator in the form of a custom expression to be attached to the supplied question.
 * It forbids the simultaneous selection of any answer choice together with the one with role "otherExclusive".
 *
 * The expression is constructed as a simple OR of two conditions:
 * 1. `{${questionLabel}} = ['other']` - the "other" choice is selected and nothing else
 * 2. `{${questionLabel}} notcontains 'other'` - the "other" choice is not selected
 *
 * See: {@link https://surveyjs.io/form-library/documentation/data-validation}
 *
 * @param {string} questionLabel - The label of the question to create the validator for.
 */
function getExclusiveOtherValidator(questionLabel: string) {
  return {
    type: 'expression',
    text: 'This option cannot be combined with other options',
    expression: `{${questionLabel}} = ['other'] or {${questionLabel}} notcontains 'other'`,
  };
}
